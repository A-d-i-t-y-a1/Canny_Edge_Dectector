# -*- coding: utf-8 -*-
"""MyCannyEdgeDetectorDemo.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z3wkGc_VS66JMZ3Ii3BDYlxVJ8iIb3PU
"""

from IPython.lib.pretty import Printable
from skimage import data,metrics # for inbuilt images
from skimage.color import * # for rgb2gray
from skimage.feature import *
import matplotlib.pyplot as plt
import numpy as np
import math

fig, axes = plt.subplots(1, ncols=3, figsize=(32, 16))

#input image
img=data.brick()
low_val=0.2
high_val=0.5

def convolution(image,kernal):

    #height and width of input image
    height_img=image.shape[0]
    width_img=image.shape[1]

    #height and width of kernal
    height_kernal=kernal.shape[0]
    width_kernal=kernal.shape[1]

    n=height_kernal//2
    m=width_kernal//2

    #padding the image so out of bounds doesn't occur
    padded_img=np.pad(image,pad_width=((n,n),(m,m)),mode='constant',constant_values=0).astype(np.float32) 
    image_new=np.zeros(padded_img.shape)  

    image_final=np.zeros((height_img+2*n,width_img+2*m),np.float32)

    new_height=image_new.shape[0]
    new_width=image_new.shape[1]

    for i in range(n,new_height-n):
        for j in range(m,new_width-m):
            #slicing the required part
            sliced_img=padded_img[i-n:i-n+height_kernal,j-m:j-m+width_kernal]
            sliced_img=sliced_img.flatten()*kernal.flatten()
            image_final[i][j]=sliced_img.sum()
    
    return image_final[n:n+height_img,m:m+width_img]

def guassian_blur():

    image=rgb2gray(img)
    image=np.asarray(image)
    sigma=2
    axes[0].imshow(image,cmap='gray')
    axes[0].axis('off')
    axes[0].set_title('initial image')

    kernal_size=2*int(3*sigma+0.5)+1
    guassian_filter=np.zeros((kernal_size,kernal_size),np.float32)

    m=kernal_size//2
    n=kernal_size//2

    #calculating values of kernal
    for i in range (-m,m+1):
       for j in range (-n,n+1):
          denominator=2*np.pi*(sigma**2)
          power=np.exp(-(i**2+j**2)/(2*sigma**2))
          guassian_filter[i+m,j+n]=(1/denominator)*power     

    return convolution(image,guassian_filter)
    

def sobel():
    #fetching the blurred image
    blurred_img=guassian_blur()

    Cx=np.zeros((3,3),np.float32)
    Cy=np.zeros((3,3),np.float32)

    #Cy matrix
    Cy[0][0]=1
    Cy[0][1]=2
    Cy[0][2]=1
    Cy[1][0]=0
    Cy[1][1]=0
    Cy[1][2]=0
    Cy[2][0]=-1
    Cy[2][1]=-2
    Cy[2][2]=-1

    #Cx matrix
    Cx[0][0]=-1
    Cx[0][1]=0
    Cx[0][2]=1
    Cx[1][0]=-2
    Cx[1][1]=0
    Cx[1][2]=2
    Cx[2][0]=-1
    Cx[2][1]=0
    Cx[2][2]=1

    row=blurred_img.shape[0]
    col=blurred_img.shape[1]

    sobelx=np.zeros((row,col),np.float32)
    sobely=np.zeros((row,col),np.float32)
    #convolution of blurred image and Cx
    sobelx=-1*convolution(blurred_img,Cx);
    #convolution of blurred image and Cy
    sobely=-1*convolution(blurred_img,Cy)

    edges=np.zeros((row,col),np.float32)
    #calculating theta for each edge
    theta=np.zeros((row,col),np.float32)

    for i in range (0,row):
        for j in range (0,col):
            edges[i][j]=np.hypot(sobelx[i][j],sobely[i][j])
            #converting angle in degree
            theta[i][j]=np.arctan2(sobely[i][j],sobelx[i][j])*(180/np.pi)
            if theta[i][j]<0:
                theta[i][j]=theta[i][j]+180;
    
    return (edges,theta)

def non_max_supression():
    tup=sobel()
    edges=tup[0]
    theta=tup[1]

    row=edges.shape[0]
    col=edges.shape[1]

    edges_dec=np.zeros((row,col),np.float32)

    #matching the direction of theta
    for i in range (1,row-1):
        for j in range (1,col-1):
            if (0<=theta[i][j]<22.5)or(157.5<theta[i][j]<=180):
                if (edges[i][j-1]<=edges[i][j])and(edges[i][j]>=edges[i][j+1]):
                    edges_dec[i][j]=edges[i][j]
                else:
                    edges_dec[i][j]=0  
            elif (67.5>theta[i][j]>=22.5):
                if (edges[i-1][j+1]<=edges[i][j])and(edges[i][j]>=edges[i+1][j-1]):
                    edges_dec[i][j]=edges[i][j]
                else:
                    edges_dec[i][j]=0 
            elif (112.5>theta[i][j]>=67.5):
                if (edges[i-1][j]<=edges[i][j])and(edges[i][j]>=edges[i+1][j]):
                    edges_dec[i][j]=edges[i][j]
                else:
                    edges_dec[i][j]=0 
            elif (157.5>=theta[i][j]>=112.5):
                if (edges[i-1][j-1]<=edges[i][j])and(edges[i][j]>=edges[i+1][j+1]):
                    edges_dec[i][j]=edges[i][j]
                else:
                    edges_dec[i][j]=0      

    return edges_dec  

high_threshold=0
low_threshold=0
fac=50

def threshold():
    edges_dec=non_max_supression()
    
    row=edges_dec.shape[0]
    col=edges_dec.shape[1]
    
    mx=edges_dec.max()

    low_threshold_ratio=low_val
    high_threshold_ratio=high_val

    #finding the low_threshold and high_threshold
    low_threshold=mx*low_threshold_ratio
    high_threshold=mx*high_threshold_ratio

    is_strong=np.zeros((row,col),dtype=np.int32)

    #marking the edges strong, weak and non relavent
    for i in range(0,row):
        for j in range(0,col):
            if edges_dec[i][j]>=high_threshold:
                is_strong[i][j]=2
            elif edges_dec[i][j]>low_threshold and edges_dec[i][j]<high_threshold:
                is_strong[i][j]=1
            else:
                is_strong[i][j]=0

    return is_strong

def hysterasis():
    #fetching the output after threshold
    is_strong=threshold()

    row=is_strong.shape[0]
    col=is_strong.shape[1]

    post_hysterasis=np.zeros((row,col),dtype=np.int32)

    for i in range(1,row-1):
        for j in range(1,col-1):
            if is_strong[i][j]==1:
                #checking if any of its neighbour is strong edge
                dx=np.array([1,1,1,-1,-1,-1,0,0])
                dy=np.array([1,0,-1,1,0,-1,1,-1])
                flag=0
                for k in range(0,8):
                    x=i+dx[k]
                    y=j+dy[k]
                    if is_strong[x][y]==2:
                        flag=1
                if flag==1:
                    post_hysterasis[i][j]=2
                else:
                    post_hysterasis[i][j]=0
            elif is_strong[i][j]==2:
                post_hysterasis[i][j]=2
            else:
                post_hysterasis[i][j]=0
      
    for i in range(0,row):
        for j in range(0,col):
            if post_hysterasis[i][j]==2:
                post_hysterasis[i][j]=True
            else:
                post_hysterasis[i][j]=False

    #printing the output of myCannyEdgeDectector
    axes[1].imshow(is_strong,cmap='gray')
    axes[1].axis('off')
    axes[1].set_title('Output of myCannyEdgeDectector')
    return post_hysterasis

sigma=2
input_image=canny(rgb2gray(img),sigma=sigma,high_threshold=high_val*fac,low_threshold=low_val*fac)

def myCannyEdgeDetector(image, Low_Threshold, High_Threshold):
    #fetching the image after hysterasis operation
    post_hysterasis=hysterasis()
    #calculating PSNR
    psnr=metrics.peak_signal_noise_ratio(input_image,post_hysterasis)
    print("Peak Signal to Noise Ratio (PSNR) = ",psnr)
    #calculating SSIM
    ssim=metrics.structural_similarity(input_image,post_hysterasis)
    print("Structural Similarity Index Metric = ",ssim)

    #printing the output of Canny Detector
    axes[2].imshow(input_image,cmap='gray')
    axes[2].axis('off')
    axes[2].set_title('---Output of Canny Detector---')

myCannyEdgeDetector(img,low_val,high_val)



